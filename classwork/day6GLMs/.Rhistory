rm(list=ls())
if(dirname(rstudioapi::getActiveDocumentContext()$path) != '') setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
final_df = read.csv('data.csv')
#running a simple regression on intercommunal violence (not violence with the state):
pop_logit <- glm(intercon ~ country_pop + aggdifxx + gdppc + polity2,
data=final_df,
family = binomial)
#lets get a tex table
library(stargazer)
#we might prefer Word or HTML
library(jtools)
dataToPlot = data.frame('country_pop' = seq(min(newData$country_pop), max(newData$country_pop), length.out = 1000),
'aggdifxx' = mean(newData$aggdifxx),
'gdppc' = mean(newData$gdppc),
'polity2' = mean(newData$polity2))
probs = predict(pop_logit, newdata = dataToPlot, type = 'response', se.fit = T)
lowers = probs$fit - 1.96*probs$se.fit
uppers = probs$fit + 1.96*probs$se.fit
plot(probs$fit ~ dataToPlot$country_pop, type = 'n')
points(dataToPlot$country_pop, lowers, lty = 2, type = 'l')
points(dataToPlot$country_pop, uppers, lty = 2, type = 'l')
polygon(c(rev(dataToPlot$country_pop), dataToPlot$country_pop), c(rev(uppers), lowers), col = 'grey80', border = NA)
points(probs$fit ~ dataToPlot$country_pop, type = 'l')
newData = na.omit(final_df[, c('intercon', 'country_pop', 'aggdifxx', 'gdppc', 'polity2')])
dataToPlot = data.frame('country_pop' = seq(min(newData$country_pop), max(newData$country_pop), length.out = 1000),
'aggdifxx' = mean(newData$aggdifxx),
'gdppc' = mean(newData$gdppc),
'polity2' = mean(newData$polity2))
probs = predict(pop_logit, newdata = dataToPlot, type = 'response', se.fit = T)
lowers = probs$fit - 1.96*probs$se.fit
uppers = probs$fit + 1.96*probs$se.fit
plot(probs$fit ~ dataToPlot$country_pop, type = 'n')
points(dataToPlot$country_pop, lowers, lty = 2, type = 'l')
points(dataToPlot$country_pop, uppers, lty = 2, type = 'l')
polygon(c(rev(dataToPlot$country_pop), dataToPlot$country_pop), c(rev(uppers), lowers), col = 'grey80', border = NA)
points(probs$fit ~ dataToPlot$country_pop, type = 'l')
?rug
#add a rug if you want
rug(newData$country_pop)
#in papers, you generally want an intuitive numerical explanation
#not that important for logits, cause of exp, but for GLMs in general
#we take the mean prediction, and subtract the sd
predict(pop_logit, newdata = data.frame(
'country_pop' = c(mean(newData$country_pop), mean(newData$country_pop) - sd(newData$country_pop)),
'aggdifxx' = mean(newData$aggdifxx),
'gdppc' = mean(newData$gdppc),
'polity2' = mean(newData$polity2)
))
#in papers, you generally want an intuitive numerical explanation
#not that important for logits, cause of exp, but for GLMs in general
#we take the mean prediction, and subtract the sd
diff(predict(pop_logit, newdata = data.frame(
'country_pop' = c(mean(newData$country_pop), mean(newData$country_pop) - sd(newData$country_pop)),
'aggdifxx' = mean(newData$aggdifxx),
'gdppc' = mean(newData$gdppc),
'polity2' = mean(newData$polity2)
)))
#in papers, you generally want an intuitive numerical explanation
#not that important for logits, cause of exp, but for GLMs in general
#we take the mean prediction, and subtract the sd
diff(predict(pop_logit, newdata = data.frame(
'country_pop' = c(mean(newData$country_pop), mean(newData$country_pop) - sd(newData$country_pop)),
'aggdifxx' = mean(newData$aggdifxx),
'gdppc' = mean(newData$gdppc),
'polity2' = mean(newData$polity2)
), type = 'response'))
#or we might report the max to min
diff(predict(pop_logit, newdata = data.frame(
'country_pop' = c(max(newData$country_pop), min(newData$country_pop)),
'aggdifxx' = mean(newData$aggdifxx),
'gdppc' = mean(newData$gdppc),
'polity2' = mean(newData$polity2)
), type = 'response'))
#now we compare to the null model to check for explanatory power
pop_logitNull <- glm(intercon ~ aggdifxx + gdppc + polity2,
data=final_df,
family = binomial)
#analysis of variance
anova(pop_logit, pop_logitNull)
?anoca
?anova
#analysis of variance
anova(pop_logit, pop_logitNull, chiSq = T)
#analysis of variance
anova(pop_logit, pop_logitNull, test = 'Chisq')
stargazer(pop_logit, pop_logitNull)
#now matched cases
library(MatchIt)
pop_logit$formuka
pop_logit$formula
matchit(intercon ~ country_pop + aggdifxx + gdppc + polity2,
data = final_df,
method = 'nearest',
distance = 'mahalanobis',
replace = T)
matchit(intercon ~ country_pop + aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest',
distance = 'mahalanobis',
replace = T)
match.out = matchit(intercon ~ country_pop + aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest',
distance = 'mahalanobis',
replace = T)
match.out$match.matrix
match.out$match.matrix[[1:2,]]
match.out$match.matrix[1:2,]
match.out$match.matrix[1:2]
match.out$match.matrix
head(match.out$match.matrix)
match.out$match.matrix[c(1,3)]
matches = match.out$match.matrix[c(1,3)]
newData$intercon[matches,]
newData[matches,]
#nothing there, because its binomial
#find where intercon differs
matchesFull = match.out$match.matrix
newData$intercon
newData$intercon[matchesFull]
#nothing there, because its binomial
#find where intercon differs
#report the means (for GLMs)
matchesFull = match.out$match.matrix
newData$intercon[matchesFull]
newData$intercon[matchesFull]
newData$intercon
matchesFull
newData$intercon[as.numeric(matchesFull)]
as.numeric(matchesFull)
?matchit
matchesFull
dim(matchesFull)
#now matched cases
library(Matching)
#now matched cases
library(Matching)
match.out = MatchBalance(intercon ~ country_pop + aggdifxx + gdppc + polity2,
data = newData)
match.out = Match(intercon ~ country_pop + aggdifxx + gdppc + polity2,
data = newData)
match.out = Match(intercon ~ country_pop + aggdifxx + gdppc + polity2)
?Match
match.out = Match(Y = newData$intercon,
X = newData[, c('country_pop', 'aggdifxx', 'gdppc', 'polity2')])
match.out = Match(Y = newData$intercon,
Tr = newData$country_pop,
X = newData[, c('country_pop', 'aggdifxx', 'gdppc', 'polity2')])
match.out = Match(Y = newData$intercon,
Tr = newData$country_pop > mean(newData$country_pop),
X = newData[, c('country_pop', 'aggdifxx', 'gdppc', 'polity2')])
match.out
match.out = Match(Y = newData$intercon,
Tr = newData$country_pop > mean(newData$country_pop),
X = newData[, c('country_pop', 'aggdifxx', 'gdppc', 'polity2')],
replace = T)
match.out
matchOut = Match(Y = newData$intercon,
Tr = newData$country_pop > mean(newData$country_pop),
X = newData[, c('country_pop', 'aggdifxx', 'gdppc', 'polity2')],
replace = T)
matchOut$mdata
#now matched cases
library(MatchIt)
match.out = matchit(intercon ~ I(country_pop > mean(newData$country_pop))
+ aggdifxx + gdppc + polity2,
data = newData)
match.out = matchit(intercon ~ I(country_pop > mean(newData$country_pop))
+ aggdifxx + gdppc + polity2,
data = newData,
replace = T)
match.out$match.matrix
head(match.out$match.matrix)
match.out = matchit(intercon ~ I(country_pop > mean(newData$country_pop))
+ aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest', distance = 'mahalanobis',
replace = T)
match.out = matchit(I(country_pop > mean(newData$country_pop)) ~
+ aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest', distance = 'mahalanobis',
replace = T)
match.out$match.matrix
head(match.out$match.matrix)
match.out = matchit(I(country_pop > mean(country_pop)) ~
+ aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest', distance = 'mahalanobis',
replace = T)
head(match.out$match.matrix)
head(match.out)
match.out = matchit(I(country_pop > mean(country_pop)) ~
aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest', distance = 'mahalanobis',
replace = T)
head(match.out)
head(match.out$match.matrix)
match.out
?matchit
match.out = matchit(I(country_pop > mean(country_pop)) ~
aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest', distance = 'mahalanobis',
replace = T)
match.out$match.matrix
head(match.out$match.matrix)
as.numeric(match.out$match.matrix)
matches = as.numeric(match.out$match.matrix)
matches2 = rownames(match.out$match.matrix)
newData[matches2, 'intercon'] - newData[matches, 'intercon']
matches2
matches = as.numeric(match.out$match.matrix)
matches2 = as.numeric(rownames(match.out$match.matrix))
newData[matches2, 'intercon'] - newData[matches, 'intercon']
matches2
newData
match.out = matchit(I(country_pop > mean(country_pop)) ~
aggdifxx + gdppc + polity2,
data = newData,
method = 'nearest', distance = 'mahalanobis',
replace = T)
matches = as.numeric(match.out$match.matrix)
matches2 = as.numeric(rownames(match.out$match.matrix))
newData[matches2, 'intercon'] - newData[matches, 'intercon']
as.numeric(rownames(match.out$match.matrix))
rownames(newData)
as.numeric(rownames(newData))
matches = as.numeric(match.out$match.matrix)
matches2 = as.numeric(rownames(newData))
newData[matches2, 'intercon'] - newData[matches, 'intercon']
matches = as.numeric(match.out$match.matrix)
matches2 = as.numeric(row.names(match.out$match.matrix))
newData[matches2, 'intercon'] - newData[matches, 'intercon']
matches
match.out$match.matrix
final_df[matches2, 'intercon'] - final_df[matches, 'intercon']
mean(final_df[matches2, 'intercon'] - final_df[matches, 'intercon'])
final_df[matches2[1], 'intercon'] - final_df[matches[1], 'intercon']
#now running the ordered logit regression on rebellion score
library(MASS)
pop_olr <- polr(as.factor(rebellion) ~ country_pop + aggdifxx + gdppc + polity2,
data=final_df)
summary(pop_olr)
con_olr <- polr(as.factor(rebellion) ~ groupcon + aggdifxx + gdppc + polity2,
data=final_df)
summary(con_olr)
pop_olrNull <- polr(as.factor(rebellion) ~ aggdifxx + gdppc + polity2,
data=final_df)
anova(pop_olr, pop_olrNull)
#plot the results of a polr
probs = predict(pop_olr, newData, se.fit = TRUE, type = 'probs')
probs
newData
#plot the results of a polr
newData = na.omit(final_df[, c('rebellion', 'country_pop', 'aggdifxx', 'gdppc', 'polity2')])
probs = predict(pop_olr, newData, se.fit = TRUE, type = 'probs')
probs$lower <- probs$fit - (1.96*probs$se.fit) # lower bounds
probs = predict(pop_olr, newData, se.fit = TRUE, type = 'response')
probs$lower <- probs$fit - (1.96*probs$se.fit) # lower bounds
probs = predict(pop_olr, newData, se.fit = TRUE, type = 'response')
probs = predict(pop_olr, newData, se.fit = TRUE, type = 'probs')
probs
probs = as.data.frame(predict(pop_olr, newData, se.fit = TRUE, type = 'probs'))
probs$lower <- probs$fit - (1.96*probs$se.fit) # lower bounds
probs
probs = data.frame(predict(pop_olr, newData, se.fit = TRUE, type = 'probs'))
probs$lower <- probs$fit - (1.96*probs$se.fit) # lower bounds
head(probs)
plot(0:8, probs)
plot(0:8, probs[[1]])
plot(0:8, probs[1])
plot(0:8, probs[,1])
probs[,1]
plot(0:8, probs[1,])
for(i in 2:nrow(newData)) points(0:8, probs[i,])
plot(0:8, probs[1,], type = 'b')
plot(0:8, probs[1,], type = 'b', pch = 18)
plot(0:8, probs[1,], type = 'b', pch = 18)
for(i in 2:nrow(newData)) points(0:8, probs[i,], type = 'b', pch = 18)
